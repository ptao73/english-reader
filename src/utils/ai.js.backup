import { db } from '../db/schema.js';

/**
 * AIåˆ†ææœåŠ¡
 * å®ç°ä¸‰å±‚ç¼“å­˜ç­–ç•¥:
 * L1: IndexedDBæœ¬åœ°ç¼“å­˜
 * L2: GitHubäº‘ç«¯ç¼“å­˜(æœªæ¥å®ç°)
 * L3: å®æ—¶AIè°ƒç”¨
 */

const ANTHROPIC_API_KEY = import.meta.env.VITE_ANTHROPIC_API_KEY || '';
const API_ENDPOINT = 'https://api.anthropic.com/v1/messages';

/**
 * æ ¸å¿ƒPrompt: å¥å­ä¸‰å±‚åˆ†æ
 */
const SENTENCE_ANALYSIS_PROMPT = (sentence) => `
è¯·åˆ†ä¸‰å±‚åˆ†æè¿™ä¸ªè‹±æ–‡å¥å­,ä¸¥æ ¼æŒ‰ç…§JSONæ ¼å¼è¾“å‡º:

å¥å­: "${sentence}"

è¦æ±‚:
1. hint: ç¬¬ä¸€å±‚æç¤º - åªç»™å…³é”®è¯ã€å¥å‹éª¨æ¶,1-2è¡Œ,å¸®åŠ©æ€è€ƒä½†ä¸ç»™ç­”æ¡ˆ
2. analysis: ç¬¬äºŒå±‚æ·±åº¦åˆ†æ - è¯­æ³•ç»“æ„ã€å›ºå®šæ­é…ã€æ˜“é”™ç‚¹,3-5æ®µ,ä¸åŒ…å«ä¸­æ–‡ç¿»è¯‘
3. zh: ç¬¬ä¸‰å±‚ä¸­æ–‡ç¿»è¯‘ - å‡†ç¡®ã€è‡ªç„¶çš„ä¸­æ–‡

è¾“å‡ºJSONæ ¼å¼:
{
  "hint": "...",
  "analysis": "...",
  "zh": "..."
}

ç¤ºä¾‹:
{
  "hint": "ä¸»è¯­: implementation | è°“è¯­: has revolutionized | å¥å‹: ç°åœ¨å®Œæˆæ—¶",
  "analysis": "è¯­æ³•ç»“æ„:\\n- ä¸»å¥: The implementation has revolutionized...\\n- å®šè¯­ä»å¥: the way (that) students learn\\n\\né‡ç‚¹è¯ç»„:\\n- implementation of: ...çš„å®æ–½\\n- revolutionize: å½»åº•æ”¹å˜(æ¯”changeæ›´å¼ºçƒˆ)\\n\\næ˜“é”™ç‚¹:\\n- has revolutionized ç”¨ç°åœ¨å®Œæˆæ—¶,å¼ºè°ƒ\\"å·²ç»äº§ç”Ÿçš„å½±å“\\"",
  "zh": "äººå·¥æ™ºèƒ½åœ¨æ•™è‚²ä¸­çš„åº”ç”¨å½»åº•æ”¹å˜äº†å­¦ç”Ÿå­¦ä¹ å’Œä¸æ•™è‚²å†…å®¹äº’åŠ¨çš„æ–¹å¼ã€‚"
}

åªè¾“å‡ºJSON,ä¸è¦å…¶ä»–å†…å®¹ã€‚
`;

/**
 * è°ƒç”¨Claude API
 */
async function callClaudeAPI(prompt) {
  if (!ANTHROPIC_API_KEY) {
    throw new Error('æœªé…ç½®ANTHROPIC_API_KEY,è¯·åœ¨.envæ–‡ä»¶ä¸­è®¾ç½®VITE_ANTHROPIC_API_KEY');
  }

  const response = await fetch(API_ENDPOINT, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': ANTHROPIC_API_KEY,
      'anthropic-version': '2023-06-01'
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1000,
      messages: [
        { role: 'user', content: prompt }
      ]
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`APIè°ƒç”¨å¤±è´¥: ${error.error?.message || response.statusText}`);
  }

  const data = await response.json();
  const text = data.content[0].text;
  
  // è§£æJSONå“åº”
  try {
    // å»é™¤å¯èƒ½çš„markdownä»£ç å—æ ‡è®°
    const cleanText = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    return JSON.parse(cleanText);
  } catch (e) {
    console.error('JSONè§£æå¤±è´¥:', text);
    throw new Error('AIè¿”å›æ ¼å¼é”™è¯¯');
  }
}

/**
 * è·å–å¥å­åˆ†æ(ä¸‰å±‚ç¼“å­˜)
 * @param {string} sentenceId - å¥å­ID
 * @param {string} sentenceText - å¥å­æ–‡æœ¬
 * @returns {Promise<Object>} - {hint, analysis, zh}
 */
export async function getSentenceAnalysis(sentenceId, sentenceText) {
  // L1: æŸ¥è¯¢æœ¬åœ°ç¼“å­˜
  const cached = await db.aiCache.get(sentenceId);
  if (cached) {
    console.log('âœ… L1ç¼“å­˜å‘½ä¸­:', sentenceId);
    return cached.data;
  }

  // L2: æŸ¥è¯¢GitHubç¼“å­˜(æœªæ¥å®ç°)
  // TODO: å®ç°GitHubç¼“å­˜æŸ¥è¯¢

  // L3: è°ƒç”¨AI
  console.log('ğŸ”„ è°ƒç”¨AIåˆ†æ:', sentenceId);
  const prompt = SENTENCE_ANALYSIS_PROMPT(sentenceText);
  const result = await callClaudeAPI(prompt);

  // åŒ…è£…å®Œæ•´æ•°æ®
  const analysisData = {
    sentenceId,
    text: sentenceText,
    hint: result.hint,
    analysis: result.analysis,
    zh: result.zh,
    cachedAt: new Date().toISOString()
  };

  // å†™å…¥L1ç¼“å­˜
  await db.aiCache.put({
    key: sentenceId,
    type: 'sentence',
    data: analysisData,
    createdAt: new Date().toISOString()
  });

  console.log('âœ… å·²ç¼“å­˜:', sentenceId);

  return analysisData;
}

/**
 * è·å–å•è¯åˆ†æ(æœªæ¥å®ç°)
 */
export async function getWordAnalysis(word) {
  // ç±»ä¼¼é€»è¾‘
  const cached = await db.aiCache.get(word);
  if (cached) {
    return cached.data;
  }

  // TODO: å®ç°å•è¯åˆ†æprompt
  const result = {
    word,
    definition: 'å¾…å®ç°',
    etymology: {},
    examples: []
  };

  await db.aiCache.put({
    key: word,
    type: 'word',
    data: result,
    createdAt: new Date().toISOString()
  });

  return result;
}

/**
 * æ¸…ç†ç¼“å­˜
 */
export async function clearCache() {
  await db.aiCache.clear();
  console.log('âœ… ç¼“å­˜å·²æ¸…ç©º');
}

/**
 * è·å–ç¼“å­˜ç»Ÿè®¡
 */
export async function getCacheStats() {
  const sentenceCacheCount = await db.aiCache.where('type').equals('sentence').count();
  const wordCacheCount = await db.aiCache.where('type').equals('word').count();
  
  return {
    sentences: sentenceCacheCount,
    words: wordCacheCount,
    total: sentenceCacheCount + wordCacheCount
  };
}
